const os = require("os");
const fs = require("fs");
const p = require("path");
const {  writeToFile,getFilesFromDir } = require("./utils");
const { exec } = require("child_process");


const checkHasRootSchema = (paths, rootSchema) => {
  return paths.includes(rootSchema);
};

const makeRootSchemaFile = async (path) => {
  const rootSchema = `
  datasource db { 
    provider = "postgresql"
    url = env("DATASOURCE_URL")
    migrations = "lib/db/migrations"
  }

  generator client {
    provider = "prisma-client-js"
  }
  `;
  await writeToFile(path, rootSchema);
};

const checkFileExists = async(path) => {
  return new Promise((res) => {
    try {
      const exist = fs.existsSync(path)
      res(exist || false)
    } catch {
      res(false)
    }
  })
}


process.on("SIGINT",async ()=> {
  console.log("Process interrupted by user")
  const rootSchemaDirectory = "lib/db/schemas";
  const schemaPath = `${rootSchemaDirectory}/schema.prisma`;
  const schemaCreated = await checkFileExists(schemaPath)
  if(schemaCreated) { 
    fs.unlinkSync(schemaPath)
  }
})


const generateSchema = async (execPayload) => {
  const rootSchemaPath = "root.schema.prisma";
  const rootSchemaDirectory = "lib/db/schemas";
  const schemaPath = `${rootSchemaDirectory}/schema.prisma`;


 


  const hasSchemaFile = await checkFileExists(schemaPath)
  console.log("Found schema path ", hasSchemaFile)
  if (hasSchemaFile) {
    console.log("Removing existing schema file");
    fs.unlinkSync(schemaPath);
  }

   const schemaFiles = await getFilesFromDir(rootSchemaDirectory);
  console.log("Found schema files:", schemaFiles);

  const hasRootSchema = fs.existsSync(rootSchemaPath)
  if (!hasRootSchema) {
    console.log("Root schema doesn't exist. Creating ROOT.SCHEMA.PRISMA");
    await makeRootSchemaFile(rootSchemaPath);
  }

  console.log("Reading root schema...");
  const rootSchema = fs.readFileSync(
    `${rootSchemaDirectory}/${rootSchemaPath}`
  );
  const schemaPaths = schemaFiles.filter((path) => path !== rootSchemaPath);
  console.log("Reading additional schema files:", schemaPaths);

  const schemaContentArr = schemaPaths.map((path) => {
    console.log("Reading file:::", path)
    return fs.readFileSync(`${rootSchemaDirectory}/${path}`, "utf-8")
  }
  );
  const schemaStr = ['// this file is auto-generated by the generate-db-schema. do not make any manual changes',rootSchema, ...schemaContentArr].join("\n\n");

  
  console.log("Writing combined schema to:", schemaPath);
  fs.writeFileSync(schemaPath, schemaStr, "utf-8");

  const prismaExecPath = p.resolve(process.cwd(), "node_modules/.bin/prisma");
  console.log("Prisma executable path:", prismaExecPath);

  const migrationName = `migration-${new Date().getTime()}`

  const schemaFileExists = fs.existsSync(schemaPath);
  if (schemaFileExists) {
    console.log("Executing Prisma migrate command...");
    exec(
      `${execPayload?.resetMigrations ? ` ${prismaExecPath} migrate reset --schema=${schemaPath} --force &&`: ""} ${prismaExecPath} migrate dev --schema=${schemaPath} --name=${migrationName}`,
      {
        env: {
          ...process.env,
          PATH: process.env.PATH,
          DATASOURCE_URL:
            "postgresql://postgres:postgres@localhost:5432/product-catalog-db?schema=public",
        },
      },
      async (err, stdout, stderr) => {
        console.log("Migration command completed");
        console.log("Error:", err);
        console.log("Stdout:", stdout);
        console.log("Stderr:", stderr);

        if (err) {
          console.log("Migrate failed  ", err);
          fs.unlinkSync(schemaPath)
          return;
        }
        if (stderr) {
          console.log("Migrate failed ::: ", stderr);
          fs.unlinkSync(schemaPath)
          return;
        }
        if (stdout) {
          console.log("Result :::", { stdout });
        }
        if (!err && !stderr) {
          console.log("Migration completed successfully");
        }
      }
    );
  }
};


function getExecPayload() {
  const payload = {
   resetMigrations: false,
  }

  payload.resetMigrations = process.argv.some(arg => arg === "--reset-migration")

  return payload  
}


async function  main() {
  try {
    const executionPayload = getExecPayload()
    await generateSchema(executionPayload)
  } catch (error) {
    console.log("Error generating schema   ", error)
  }
}

main()