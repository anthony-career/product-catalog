const fs = require("fs");
const p = require("path");
const { writeToFile, getFilesFromDir } = require("./utils");
const { spawn } = require("child_process");

const makeRootSchemaFile = async (path) => {
  const rootSchema = `
  datasource db { 
    provider = "postgresql"
    url = env("DATASOURCE_URL")
    migrations = "lib/db/migrations"
  }

  generator client {
    provider = "prisma-client-js"
  }
  `;
  await writeToFile(path, rootSchema);
};

const checkFileExists = async (path) => {
  return new Promise((res) => {
    try {
      const exist = fs.existsSync(path);
      res(exist || false);
    } catch {
      res(false);
    }
  });
};

process.on("SIGINT", async () => {
  const rootSchemaDirectory = "lib/db/schemas";
  const schemaPath = `${rootSchemaDirectory}/schema.prisma`;
  const schemaCreated = fs.existsSync(schemaPath);
  if (schemaCreated) {
    // fs.unlinkSync(schemaPath);
  }
  process.exit(0);
});

const runMigration = async (
  execPayload,
  prismaExecPath,
  schemaPath,
  migrationName
) => {
  const args = [
    ...(execPayload?.resetMigrations
      ? ["migrate", "reset", `--schema=${schemaPath}`, "--force"]
      : []),
    "migrate",
    "dev",
    `--schema=${schemaPath}`,
    `--name=${migrationName}`,
  ];

  const prismaProcess = spawn(prismaExecPath, args, {
    stdio: "inherit",
    env: {
      ...process.env,
      PATH: process.env.PATH,
      DATASOURCE_URL:
        "postgresql://postgres:postgres@localhost:5432/product-catalog-db?schema=public",
    },
  });

  prismaProcess.on("close", (code) => {
    if (code !== 0) {
      console.log(`Process exited with code ${code}`);
      fs.unlinkSync(schemaPath);
    } else {
      console.log("Migration completed successfully");
    }
  });
};

const runGenerate = async (prismaExecPath, schemaPath) => {
  const prismaProcess = spawn(
    prismaExecPath,
    ["generate", `--schema=${schemaPath}`],
    {
      stdio: "inherit",
      env: {
        ...process.env,
        PATH: process.env.PATH,
        DATASOURCE_URL:
          "postgresql://postgres:postgres@localhost:5432/product-catalog-db?schema=public",
      },
    }
  );

  prismaProcess.on("close", (code) => {
    if (code !== 0) {
      console.log(`Process exited with code ${code}`);
      fs.unlinkSync(schemaPath);
    } else {
      console.log("Generate completed successfully");
    }
  });
};

const startProcess = async (execPayload) => {
  const rootSchemaPath = "root.schema.prisma";
  const rootSchemaDirectory = "lib/db/schemas";
  const schemaPath = `${rootSchemaDirectory}/schema.prisma`;

  const hasSchemaFile = await checkFileExists(schemaPath);
  if (hasSchemaFile) {
    fs.unlinkSync(schemaPath);
  }

  const schemaFiles = await getFilesFromDir(rootSchemaDirectory);

  const hasRootSchema = fs.existsSync(rootSchemaPath);
  if (!hasRootSchema) {
    await makeRootSchemaFile(rootSchemaPath);
  }

  const rootSchema = fs.readFileSync(
    `${rootSchemaDirectory}/${rootSchemaPath}`
  );
  const schemaPaths = schemaFiles.filter((path) => path !== rootSchemaPath);

  const schemaContentArr = schemaPaths.map((path) => {
    return fs.readFileSync(`${rootSchemaDirectory}/${path}`, "utf-8");
  });
  const schemaStr = [
    "// this file is auto-generated by the generate-db-schema. do not make any manual changes",
    rootSchema,
    ...schemaContentArr,
  ].join("\n\n");

  console.log("schemaStr :::: \n\n", schemaStr);

  fs.writeFileSync(schemaPath, schemaStr, "utf-8");

  const prismaExecPath = p.resolve(process.cwd(), "node_modules/.bin/prisma");

  const migrationName = `migration-${new Date().getTime()}`;

  const schemaFileExists = fs.existsSync(schemaPath);
  if (schemaFileExists) {
    if (execPayload.generate) {
      return await runGenerate(prismaExecPath, schemaPath);
    } else {
      return await runMigration(
        execPayload,
        prismaExecPath,
        schemaPath,
        migrationName
      );
    }
  }
};

function getExecPayload() {
  const payload = {
    resetMigrations: false,
    generate: false,
  };

  payload.resetMigrations = process.argv.some(
    (arg) => arg === "--reset-migration"
  );

  payload.generate = process.argv.some((arg) => arg === "--generate");

  return payload;
}

async function main() {
  try {
    const executionPayload = getExecPayload();
    await startProcess(executionPayload);
  } catch (error) {
    console.log("Error generating schema   ", error);
  }
}

main();
